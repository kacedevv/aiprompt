import { GoogleGenAI } from "@google/genai";

// üëâ ƒê·∫∑t bi·∫øn n√†y trong Vercel: GEMINI_API_KEY
// Project Settings ‚Üí Environment Variables ‚Üí KEY = GEMINI_API_KEY, VALUE = <api key c·ªßa b·∫°n>
const apiKey = process.env.GEMINI_API_KEY;

if (!apiKey) {
  throw new Error(
    "Thi·∫øu GEMINI_API_KEY. H√£y c·∫•u h√¨nh trong Vercel Project Settings ‚Üí Environment Variables."
  );
}

// File n√†y ph·∫£i ch·∫°y ·ªü m√¥i tr∆∞·ªùng server (API route / serverless function),
// kh√¥ng import tr·ª±c ti·∫øp v√†o component client ƒë·ªÉ tr√°nh l·ªô key.
const ai = new GoogleGenAI({ apiKey });

/**
 * Edits an image using Gemini 2.5 Flash Image ("Nano Banana").
 */
export const editImageWithGemini = async (
  base64Image: string, 
  prompt: string, 
  mimeType: string = 'image/png'
): Promise<string> => {
  try {
    const cleanBase64 = base64Image.replace(/^data:image\/(png|jpeg|jpg|webp);base64,/, '');

    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash-image',
      contents: {
        parts: [
          { inlineData: { data: cleanBase64, mimeType: mimeType } },
          { text: prompt },
        ],
      },
    });

    if (response.candidates && response.candidates[0].content.parts) {
      for (const part of response.candidates[0].content.parts) {
        if (part.inlineData && part.inlineData.data) {
          return `data:${part.inlineData.mimeType || 'image/png'};base64,${part.inlineData.data}`;
        }
      }
    }
    throw new Error("No image generated by the model.");
  } catch (error) {
    console.error("Gemini API Error:", error);
    throw error;
  }
};

/**
 * Generates a Meme based on caption or template description.
 * Can be used with or without a source image.
 */
export const generateMeme = async (
  prompt: string,
  style: string,
  base64Image?: string
): Promise<string> => {
  try {
    const finalPrompt = `Create a meme image. Caption: "${prompt}". Style: ${style}. ensure the text is legible and funny.`;
    
    const parts: any[] = [{ text: finalPrompt }];

    if (base64Image) {
      const cleanBase64 = base64Image.replace(/^data:image\/(png|jpeg|jpg|webp);base64,/, '');
      parts.unshift({ inlineData: { data: cleanBase64, mimeType: 'image/png' } });
    }

    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash-image',
      contents: { parts },
    });

    if (response.candidates && response.candidates[0].content.parts) {
      for (const part of response.candidates[0].content.parts) {
        if (part.inlineData && part.inlineData.data) {
          return `data:${part.inlineData.mimeType || 'image/png'};base64,${part.inlineData.data}`;
        }
      }
    }
    throw new Error("Meme generation failed.");
  } catch (error) {
    console.error("Meme Gen Error:", error);
    throw error;
  }
};

/**
 * Generates a Notion-style Personal Profile (HTML code).
 */
export const generateNotionProfile = async (userInfo: string): Promise<string> => {
  try {
    const prompt = `
      Create a single-file HTML (with embedded Tailwind CSS via CDN) for a Personal Profile Page in the style of "Notion" (Minimalist, emoji icons, clean typography, whitespace).
      
      User Information:
      ${userInfo}
      
      Requirements:
      - Use a Notion-like font stack (Inter, sans-serif).
      - Include a cover image placeholder (use unplash source url).
      - Include an emoji icon for the profile picture/icon.
      - Layout: Cover -> Icon -> Title (Name) -> Properties (Tags) -> Content sections.
      - Return ONLY the raw HTML code, no markdown backticks.
    `;

    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash',
      contents: prompt,
    });

    let text = response.text || "";
    // Clean up markdown code blocks if present
    text = text.replace(/```html/g, '').replace(/```/g, '');
    return text;
  } catch (error) {
    console.error("Profile Gen Error:", error);
    throw error;
  }
};

/**
 * Rewrites text in a specific celebrity style.
 */
export const rewriteText = async (text: string, style: string): Promise<string> => {
  try {
    const prompt = `
      Rewrite the following text in the Vietnamese language, mimicking the style of: ${style}.
      
      Original Text:
      "${text}"
      
      Style Nuances:
      - S∆°n T√πng M-TP: Abstract, sky, dreams, slightly arrogant but poetic, use words like "b·∫ßu tr·ªùi", "c∆°n m∆∞a".
      - ƒêen V√¢u: Metaphorical, humble, rap lyrics flow, observational, daily life struggles, nature.
      - Th∆° Xu√¢n Qu·ª≥nh: Feminine, intense love, waves ("s√≥ng"), traditional poetic structure, emotional.
      - Academic (H·ªçc thu·∫≠t): Formal, complex vocabulary, structured, objective.
      - Romantic (L√£ng m·∫°n): Cheesy, emotional, flowery adjectives.
      
      Output only the rewritten text.
    `;

    const response = await ai.models.generateContent({
      model: 'gemini-2.5-flash',
      contents: prompt,
    });

    return response.text || "Could not generate text.";
  } catch (error) {
    console.error("Rewrite Error:", error);
    throw error;
  }
};
